# Summary

This example shows how to use an optimization method to obtain
cantilever beam dimensions that minimize cross-sectional area while
meeting robustness criteria.
 
### Run Dakota
    $ dakota -i dakota_opt_qnewton_constrained.in -o dakota_opt_qnewton_constrained.out
 
### More about running this example
This example uses the driver cantilever.py, which requires Python and
numpy.  Additionally, it makes use of a Dakota Python utility, so
PYTHONPATH will need to be set to share/dakota/Python in your Dakota installation.
 
# What problem does this solve?
The goal is to determine the width (w) and thickness (t) of a
cantilever beam that minimize the cross-sectional area while keeping
stress and displacement under horizontal and vertical loads within
acceptable bounds.  Stress is a function of width, thickness, and
loads (X, Y).  Displacement is a function of width, thickness, length
(L), loads, and Young's modulus (E).  In this problem, width and
thickness are the only quantities to be varied; all others are fixed.
 
## Math Equation
Mathematically, the problem described above is defined as follows:

_minimize:_ $` \qquad \qquad area = w t `$

_subject to:_ $` \qquad \qquad \frac{\mathtt{stress}}{R}-1 \leq 0 `$

$` \qquad \qquad \qquad \qquad \frac{\mathtt{displacement}}{D_{0}}-1 \leq 0 `$

$` \qquad \qquad \qquad \qquad 1.0 \leq w \leq 10.0 `$

$` \qquad \qquad \qquad \qquad 1.0 \leq t \leq 10.0 `$

where

$` \qquad \qquad \qquad \qquad \mathtt{stress} = \frac{600}{w t^2}Y+\frac{600}{w^2t}X `$

$` \qquad \qquad \qquad \qquad \mathtt{displacement} = \frac{4L^3}{E w t}
  \sqrt{\bigg(\frac{Y}{t^2}\bigg)^2+\bigg(\frac{X}{w^2}\bigg)^2}
  \leq D_{0} `$

and $`R`$ and $`D_{0}`$ are the requisite thresholds for stress and 
displacement, respectively

# What method will we use?
This example employs a quasi-Newton method, which is a gradient-base
optimization method that can accommodate all types of constraints.  In
addition to the ability to handle constraints, this method is chosen
because the responses in this problem are smooth and well behaved.
Gradient-based are the most efficient methods for such problems.
In this example, gradients are approximated using Dakota's finite
differencing.  Hessians are not provided, but the quasi-Newton will
approximate them.  The underlying premise governing how the method
works is based on iteratively computing a local gradient, setting it
to zero, and solving the resulting system of equations until a local
minimum is reached.
 
## Analysis Driver
The analysis driver for this example is cantilever.py, a Python script
that is invoked via Dakota fork interface.  It makes use of a
Dakota-provided Python utility to read in the variable values
generated by Dakota.  It then computes the values of area, the
stress-related constraint, and the displacement-related constraint as
defined in the mathematical equations above.  It writes those values
out for Dakota to access.

### Inputs

This version of the cantilever driver requires two inputs, the
width and thickness of the beam.

### Outputs

The driver writes three responses: area, stress, and displacement.

# Interpret the results

The output generated by Dakota can be found in
dakota\_opt\_qnewton\_constrained.out, specified in the command to run
Dakota.  It captures output that would be printed to the screen if not
directed to an output file on the command line.  There is an
additional output file, OPT\_DEFAULT.out, generated, but the content is
only really useful to those who are experts on this method.


## Screen Output
The output below appears at the end of
dakota\_opt\_qnewton\_constrained.out (or screen output if it hasn't been
redirected on the command line).  It includes the final variable
values and corresponding response values.
```
<<<<< Function evaluation summary: 39 total (39 new, 0 duplicate)
<<<<< Best parameters          =
                      2.3520340723e+00 w
                      3.3262784853e+00 t
<<<<< Best objective function  =
                      7.8235203315e+00
<<<<< Best constraint values   =
                     -1.6009004238e-02
                     -9.1577967432e-11
<<<<< Best data captured at function evaluation 37


<<<<< Iterator optpp_q_newton completed.
<<<<< Environment execution completed.
DAKOTA execution time in seconds:
  Total CPU        =       0.08 [parent =   0.085885, child =  -0.005885]
  Total wall clock =    3.51154
```
